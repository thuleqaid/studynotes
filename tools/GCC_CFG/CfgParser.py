import os
import re
import logging

# parsing cfg file
# cfg file: source codes formatted by gcc
#           generated by adding '--dump-tree-cfg'

class CfgFunc(object):
    def __init__(self,states,log=logging.getLogger()):
        self._log=log
        # regex patterns
        self._re_goto=re.compile(r'^\s+goto\s+(?P<label1><.+?>)(\s+\((?P<label2>.+?)\))?;$')
        self._re_switch=re.compile(r'^\s+switch\s+\((?P<var>.+)\)\s+<(?P<case>.+)>$')
        # parse func name and params
        self._parsefuncdecl(states[0])
        # parse func source
        self._parsebody(states[2:-1])
    def _parsefuncdecl(self,funcdecl):
        self._log.debug('CfgFunc:ParseFuncDecl:'+funcdecl)
        i=funcdecl.index('(')
        j=funcdecl.rindex(')')
        self._funcname=funcdecl[0:i-1]
        self._params=[]
        if j<=i+1:
            # no params
            pass
        else:
            params=funcdecl[i+1:j]
            for part in params.split(','):
                i=part.rindex(' ')
                self._params.append(part[i+1:])
    def _parsebody(self,states):
        # func source is consisted by local vars declaration block and several code blocks
        # local vars declaration block goes first without a label if exists
        # the first line of a code block is "Label:" with nothing else
        self._log.debug('CfgFunc:ParseFuncBody:'+":".join(states))
        sects=[]
        self._localvars=[]
        self._edges=[]
        self._block={}
        self._prevlabel=''
        self._firstlabel=''
        self._lastlabel=''
        for line in states:
            if line:
                if line.startswith(' '):
                    pass
                else:
                    # new code block starts
                    self._parsesect(sects)
                    sects=[]
                sects.append(line)
        # parse the last code block
        self._parsesect(sects)
    def _parsesect(self,states):
        if states[0].startswith(' '):
            # local vars declaration block
            for line in states:
                self._localvars.append(line[line.rindex(' ')+1:-1])
        else:
            # code block
            blocklabel=states[0][:-1]
            if not self._firstlabel:
                self._firstlabel=blocklabel
            if self._prevlabel:
                self._edges.append((self._prevlabel,blocklabel,""))
                self._prevlabel=''
            # code block patterns:
            # pattern 1:
            #  lines
            #  goto xxx;
            # pattern 2:
            #  lines
            #  if (...)
            #    goto xxx;
            #  else
            #    goto xxx;
            # pattern 3:
            #  lines
            #  switch (xxx) <xxx>
            # pattern 4:
            #  lines
            #  return ...
            # pattern 5:
            #  lines
            #
            #  next block
            if states[-1].startswith('  goto'):
                # pattern 1
                reret=self._re_goto.search(states[-1])
                if reret:
                    if reret.group('label2'):
                        label=reret.group('label2')
                    else:
                        label=reret.group('label1')
                    self._edges.append((blocklabel,label,""))
                    self._block[blocklabel]='\\l'.join(states[1:-1])+'\\l'
                else:
                    # regex pattern error
                    self._log.error('CfgFunc:RegExPattern:'+states[-1])
            elif states[-1].startswith('    goto'):
                # pattern 2
                conditionindex=states[-4].find('(')
                if conditionindex>=0:
                    condition=states[-4][conditionindex+1:-1]
                    # True path
                    reret=self._re_goto.search(states[-3])
                    if reret:
                        if reret.group('label2'):
                            label=reret.group('label2')
                        else:
                            label=reret.group('label1')
                        self._edges.append((blocklabel,label,condition))
                    else:
                        # regex pattern error
                        self._log.error('CfgFunc:RegExPattern:'+states[-3])
                    # False path
                    reret=self._re_goto.search(states[-1])
                    if condition.find(' == ')>=0:
                        condition=condition.replace(' == ',' != ')
                    elif condition.find(' != ')>=0:
                        condition=condition.replace(' != ',' == ')
                    elif condition.find(' <= ')>=0:
                        condition=condition.replace(' <= ',' > ')
                    elif condition.find(' >= ')>=0:
                        condition=condition.replace(' >= ',' < ')
                    elif condition.find(' < ')>=0:
                        condition=condition.replace(' < ',' >= ')
                    elif condition.find(' > ')>=0:
                        condition=condition.replace(' > ',' <= ')
                    if reret:
                        if reret.group('label2'):
                            label=reret.group('label2')
                        else:
                            label=reret.group('label1')
                        self._edges.append((blocklabel,label,condition))
                    else:
                        # regex pattern error
                        self._log.error('CfgFunc:RegExPattern:'+states[-1])
                    self._block[blocklabel]='\\l'.join(states[1:-4])+'\\l'
                else:
                    self._log.error('CfgFunc:if-CodeBlock:'+':'.join(states))
            elif states[-1].startswith('  switch'):
                # pattern 3
                reret=self._re_switch.search(states[-1])
                if reret:
                    var=reret.group('var')
                    cases=reret.group('case') # format:[default: <xx>, case x: <xx>, case x ... y: <xx>]
                    for item in cases.split(', '):
                        colon=item.index(':')
                        if item.startswith('case'):
                            self._edges.append((blocklabel,item[colon+2:],"%s == %s" % (var,item[5:colon])))
                        elif item.startswith('default'):
                            self._edges.append((blocklabel,item[colon+2:],"%s == %s" % (var,item[0:colon])))
                        else:
                            self._log.error('CfgFunc:RegExPattern:'+states[-1])
                    self._block[blocklabel]='\\l'.join(states[1:-1])+'\\l'
                else:
                    self._log.error('CfgFunc:switch-CodeBlock:'+':'.join(states))
            elif states[-1].startswith('  return'):
                # pattern 4
                self._lastlabel=blocklabel
                self._block[blocklabel]='\\l'.join(states[1:])+'\\l'
                pass
            else:
                # pattern 5
                self._prevlabel=blocklabel
                self._block[blocklabel]='\\l'.join(states[1:])+'\\l'
            # fix parse error for firefox
            self._block[blocklabel]=self._block[blocklabel].replace(r'&',r'&amp;amp;')
    def toDot(self):
        outtext="digraph %s {\n\tnode [shape=\"box\"];\n" % self._funcname
        for item in self._edges:
            outtext+="\t%s -> %s" % (item[0],item[1])
            if item[2]:
                outtext+=" [label=\"%s\"]" % item[2]
            outtext+=";\n"
        outtext+="\tEntry -> %s;\n" % self._firstlabel
        outtext+="\t%s -> Exit;\n" % self._lastlabel
        for (key,value) in (sorted(self._block.iteritems())):
            outtext+="\t%s [label=\"%s\"];\n"%(key,value)
        outtext+="\t%s [shape=\"ellipse\",label=\"%s\"];\n"%('Entry',self._funcname+'('+','.join(self._params)+')')
        outtext+="\t%s [shape=\"Mdiamond\"];\n"%('Exit')
        outtext+="}\n"
        return outtext
    def __str__(self):
        outtext=self._funcname+"\n\t"+",".join(self._params)
        outtext+="\n\t"+",".join(self._localvars)
        outtext+="\n\t('First', '%s', '')" % self._firstlabel
        for x in self._edges:
            outtext+="\n\t"+str(x)
        outtext+="\n\t('%s', 'Last', '')" % self._lastlabel
        return outtext

class CfgParser(object):
    def __init__(self,cfgfile,log=logging.getLogger()):
        self._log=log
        self._status='NoFile'
        self._setfile(cfgfile)
    def _setfile(self,cfgfile):
        if os.path.exists(cfgfile):
            self._cfgfile=cfgfile
            self._status='FileOK'
            self._parsefile()
    def _parsefile(self):
        self._funcinfo={}
        pat_funcstart=re.compile(r'^(?P<funcname>[a-zA-Z0-9_]+)\s+\(')
        pat_funcstop=re.compile(r'^}')
        funcname=''
        with open(self._cfgfile,'rU') as cfg:
            b_infunc=False
            for line in cfg.readlines():
                line=line.rstrip()
                if b_infunc:
                    states.append(line)
                    if pat_funcstop.search(line):
                        self._funcinfo[funcname]=CfgFunc(tuple(states),self._log)
                        b_infunc=False
                else:
                    retpat=pat_funcstart.search(line)
                    if retpat:
                        states=[]
                        states.append(line)
                        b_infunc=True
                        funcname=retpat.group('funcname')
    def toDot(self):
        for (key,value) in self._funcinfo.items():
            with open(key+'.dot','w') as fh:
                fh.write(value.toDot())
    def __str__(self):
        outtext=''
        outtext+="Status:\t%s\n" % self._status
        outtext+="Functions:\n"+"\n".join([str(x) for x in self._funcinfo.values()])
        return outtext


if __name__ == '__main__':
    logging.basicConfig(level=logging.WARNING)
    cfgfile='pii_src/pii_aplif.c.012t.cfg'
    cfgfile='pii_src/pii_event.c.012t.cfg'
    cfg=CfgParser(cfgfile)
    cfg.toDot()
